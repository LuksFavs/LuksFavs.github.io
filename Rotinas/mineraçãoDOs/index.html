<!DOCTYPE html>
<html class="writer-html5" lang="pt_BR" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>pdfReader.py - Almanaque SETD</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "pdfReader.py";
        var mkdocs_page_input_path = "Rotinas\\minera\u00e7\u00e3oDOs.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../..">
          <img src="../../img/Ass-Digital_Transformacao-Digital_Negativo.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Buscar documentos" aria-label="Buscar documentos" title="Digite o termo a ser buscado aqui" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Menu de navegação">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Relatorios</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Relatorios/relatorioCalculoGanhosAmbientais/">Relatório referente ao processo de cálculo de ganhos ambientais do SEI-RJ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Rotinas</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../extracaoTratamentoPainelSETD/">extracao_tratamento_painel_SETD.py</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">pdfReader.py</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#objetivo">Objetivo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#status">Status</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#funcionamento">Funcionamento</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#funcoes">Funções</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#retirar">retirar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defcolunas">defColunas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sortcolunas">sortColunas</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Menu de navegação em dispositivo móvel">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Almanaque SETD</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Documentos"></a></li>
          <li class="breadcrumb-item">Rotinas</li>
      <li class="breadcrumb-item active">pdfReader.py</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="pdfreaderpy">pdfReader.py</h1>
<h2 id="objetivo">Objetivo</h2>
<p>Realizar a extração dos decretos relacionados a uma seção do Diário Oficial do Estado do Rio de Janeiro. Atualmente mineração feita apenas para os Atos do Poder Executivo.</p>
<h2 id="status">Status</h2>
<p>Em desenvolvimento.</p>
<h2 id="funcionamento">Funcionamento</h2>
<p>Para o funcionamento desta rotina são necessárias as seguintes bibliotecas:</p>
<pre><code class="language-python">
import re
import json
import tqdm
import pymupdf

</code></pre>
<p>A rotina se baseia em repuperar os Atos Oficiais presentes no Diário Oficial(DO), separando por seus "Ids" a fim de utilizarmo-os para aplicações futuras. Ela apresenta 1 rotina principal divida em 3 partes, sendo 2 delas subrotinas.</p>
<pre><code class="language-python">
#Chamada Principal
retirar(CAMINHOPARAODO, VERBOSE)

</code></pre>
<p>A rotina é constituida de 3 Funções:</p>
<ol>
<li>
<p><a href="#retirar">Recuperação e arrumação dos blocos do documento</a></p>
</li>
<li>
<p><a href="#defColunas">Definição de colunas</a></p>
</li>
<li>
<p><a href="#sortColunas">Checagem das colunas</a></p>
</li>
</ol>
<p>Abaixo explicaremos cada uma delas de maneira detalhada.</p>
<h2 id="funcoes">Funções</h2>
<h3 id="retirar"><em>retirar</em></h3>
<pre><code class="language-python">
def retirar(filepath, verbose=False)

</code></pre>
<p>A função <em>retirar</em> é a função principal de <em>pdfReader.py</em>, nela é realizado toda a lógica de retirada e tratamento do texto do DO com auxílio das funções <em>defColunas</em> e <em>sortColunas</em>. É de responsabilidade da função <em>retirar</em> a retirada do texto contido no pdf do DO, a separação das linhas irrelevantes daquelas interessantes e o particionamento dos Atos Oficiais por seus "Ids". Ela recebe 2 argumentos, o primeiro <em>filepath</em> é o caminho para o arquivo pdf a ser lido e o segundo <em>verbose</em> serve para habilitar a impressão das etapas a fim de realização de correções no código, este último tem valor <em>False</em> como padrão.</p>
<pre><code class="language-python">
    nomeDir = &quot;DOsProcessados/Decretos/&quot;+filepath.split(&quot;/&quot;)[-1].split(&quot;.&quot;)[0]
    if not os.path.isdir(&quot;DOsProcessados&quot;):
        os.mkdir(&quot;DOsProcessados&quot;)
        os.mkdir(&quot;DOsProcessados/Decretos&quot;)
        os.mkdir(nomeDir)
    elif not os.path.isdir(nomeDir):
        os.mkdir(nomeDir)


    doc = pdf.open(filepath)
    arq = []
    for i in doc:
        for j in i.get_text(&quot;blocks&quot;):
            arq.append(j)

    achei = False
    pattern = r'(\\x[01][0-9A-Fa-f]|\\ufffd)' ## remover caracteres binarios do documento
    par = 0
    pagina = 0
    acc = []
    paragrafo= &quot;&quot;
    valor = False
    for lines in tqdm.tqdm(range(len(arq))):
        if par &lt; arq[lines][-2]:
            par = arq[lines][-2]
        else:
            par = arq[lines][-2]
            pagina+=1
        if (pagina == 1 and arq[lines][-2]&lt;19) or (pagina == 2 and arq[lines][-2]&lt;18) or (arq[lines][4]==&quot;&quot;) or (len(arq[lines][4])&lt;=2):
            continue 

        if &quot;&quot;.join(arq[lines][4].split(&quot;\n&quot;)) in [&quot;Solicite seu or\u00e7amento:   &quot;, &quot;Decreto Estadual 47.364/2020&quot;, &quot;OBRIGATORIEDADE DE CONSULTA \u00c0 IMPRENSA OFI-CIAL NAS CONTRATA\u00c7\u00d5ES DE SERVI\u00c7OS GR\u00c1FI-COS PELA ADMINISTRA\u00c7\u00c3O DIRETA E INDIRETA.&quot;, &quot;2,00R$&quot;, &quot;Livrosnovosde&quot;, &quot;at\u00e9 9,00&quot;, &quot;programamaisleitura&quot;, &quot;maisleitura@ioerj.rj.gov.br&quot;, &quot;Ler \u00e9 o maior barato!&quot;, &quot;programamaisleituramaisleitura@ioerj.rj.gov.br&quot;, &quot; acesso \u00e0 leitura.acesso \u00e0 leitura.&quot;, &quot;Endere\u00e7os&quot;]:
            continue

        if re.search(pattern,arq[lines][4].encode(&quot;unicode_escape&quot;).decode()):
            continue
        if &quot;O VALOR DA\nSEGURANÇA&quot; in arq[lines][4]:
                fraseSem = &quot;&quot;
                booleanValor = False
                for frase in arq[lines][4].split(&quot;\n&quot;):
                    if frase != &quot;O VALOR DA&quot; and not booleanValor:
                        fraseSem += frase + &quot;\n&quot;
                    elif frase == &quot;O VALOR DA&quot; or booleanValor:
                        booleanValor = True
                        paragrafo += frase
                aux = list(arq[lines])
                aux[4]=fraseSem
                aux[-1] = pagina
                acc.append(tuple(aux))
                valor = True
                continue
        elif valor:
            if acc == &quot;O VALOR DASEGURANÇAPUBLICOUNAIMPRENSA,ÉOFICIAL&quot;:
                valor = False
                paragrafo = &quot;&quot;
            else:
                paragrafo+=arq[lines][4].split(&quot;\n&quot;)[0]
        if re.search(r'ATOS DO PODER EXECUTIVO\n', arq[lines][4]):
            achei = True

        if re.search(r'Despachos do Governador\n', arq[lines][4]) or re.search(r'Secretaria de Estado da Casa Civil\n', arq[lines][4]):
            achei = False
            break
        elif achei:
            aux = list(arq[lines])
            aux[-1] = pagina
            acc.append(tuple(aux))

</code></pre>
<p>A primeira parte do código é responsável pela filtragem dos parágrafos irrelevantes do documento, ele procura no texto parágrafos chave que são repetidos em imagens, tabelas e outros itens irrelevantes para nosso processamento e retira-os a fim de evitar a poluição do texto do Atos, além de guardar a página em que o parágrafo se encontra já que esse contexto é perdido durante a leitura. O pymupdf realiza a leitura do pdf e retorna tuplas com a seguinte postura: <em>[ x0 , y0, x1, y1 , PARAGRAFOLIDO, NUMPARAGRAFOPAG, TIPO]</em>, onde x0 e y0 são os pontos de início do parágrafo, x1, y1 são os pontos finais, PARAGRAFOLIDO é o texto bruto do Ato e NUMPARAGRAFOPAG é o número de aparecimento do parágrafo na página, salvamos essa informação em uma variável chamada <em>arq</em>. Após o salvamento, percorremos <em>arq</em> procurando os parágrafos a serem eliminados e sobrescrevendo a variável TIPO com a página ao qual o parágrafo pertence.</p>
<pre><code class="language-python">    acumulador = &quot;&quot;
    ultimo = &quot;&quot;
    colunas = defColunas(acc)
    colunas = sortColunas(colunas,&quot;ATOS DO PODER EXECUTIVO\n&quot;)

    procurar = True
    for i in colunas:    
        if i[2][4] != &quot;ATOS DO PODER EXECUTIVO\n&quot; and procurar:
            print(i[2])
            continue
        procurar = False

        aux = re.search(r'Id: [0-9]*\n?', i[2][4])
        if aux :
            if len(i[2][4])&gt; aux.span()[1]:
                acumulador+=i[2][4][0:aux.span()[1]]
                out = open(nomeDir+&quot;/&quot;+i[2][4][aux.span()[0]+3:aux.span()[1]].rstrip(&quot;\n&quot;)+&quot;.txt&quot;, &quot;wb&quot;)
                out.write(acumulador.encode(&quot;utf-8&quot;))
                out.close()
                acumulador = i[2][4][aux.span()[1]:]
            else: 
                acumulador += i[2][4]
                out = open(nomeDir+&quot;/&quot;+i[2][4][aux.span()[0]+3:aux.span()[1]].lstrip(&quot; &quot;).rstrip(&quot;\n&quot;)+&quot;.txt&quot;, &quot;wb&quot;)
                out.write(acumulador.encode(&quot;utf-8&quot;))
                acumulador = &quot;&quot;
        else:
            acumulador+=i[2][4]
</code></pre>
<p>Na segunda parte do código temos a utilização das funções <em>defColuns</em> e <em>sortColuns</em>, elas realizam as rotinas de definição do tipo de coluna sendo utilizado pelo parágrafo e ordenação dos parágrafos de acordo com as coordenadas respectivamente, explicaremos o funcionamento de cada uma dessas funções mais adiante no documento. Após o retorno destas funções realizamos a separação dos Atos, essa separação é feita primeiro ignorando tudo aquilo identificado como sendo antecedente ao título Atos do Poder Executivo e em seguida acumulando os parágrafos restantes até encontrarmos um "Id", parte onde salvamos todos esses acumulados em um arquivo de nome igual ao "Id" do ato.</p>
<h3 id="defcolunas"><em>defColunas</em></h3>
<p>A função <em>defColunas</em> tem como objetivo identificar a qual tipo de coluna o parágrafo pertence. Essa categorização é feita utilizando os parâmetros presentes na tupla salva em <em>arq</em>, retornando uma nova tupla do estilo <em>[ TIPO, METRICAS, TUPLAORIGINAL ]</em> onde TIPO é a classificação da coluna, METRICAS são as métricas do parágrafo, sendo elas <em>[ TAMANHO, CENTRO, y0 e y1 ]</em> onde o <em>TAMANHO</em> é a largura do parágrafo, <em>CENTRO</em> é onde o paragrafo esta centrado e  y0, y1 são o ponto de inicio e final da altura do paragrafo, e <em>TUPLAORIGINAL</em> é a tupla anteriormente salva em <em>arq</em>. Ele recebe 2 parâmetros de entrada, o array a ser classificado e o verbose para habilitar a impressão dos debugs.</p>
<pre><code class="language-python">def defColunas(paragrafos, verbose=False):
    import re
    colunas = [[0,[],()] for _ in range(len(paragrafos))]
    # 1 = coluna 1/3 
    # 2 = coluna 2/3 
    # 3 = coluna 3/3 
    # 4 = coluna 1/2 
    # 5 = coluna 2/2 
    # 6 = coluna 1/1 
    # 9 = id coluna 3/3 
    #10 = coluna 1 2/3
    #11 = coluna 2 2/3

    def metricas(tupla):
        return [ tupla[2]-tupla[0], (tupla[2]-tupla[0])/2 + tupla[0], tupla[1], tupla[3]]

    colunaUnica=False
    anexo = 0

    for i in range(len(paragrafos)):
        colunas[i][1] = metricas(paragrafos[i])
        colunas[i][2] = paragrafos[i]
        regex = re.search(r'ANEXO ?([IVXL]+|\u00daNICO?|.*)', paragrafos[i][4])
        if regex and regex.span()[0] == 0:
            anexo+=1
        if colunas[i][1][0] &gt;341 and not re.search(r'Id: [0-9]*\n?', paragrafos[i][4]):
            if colunas[i][1][1] &lt; 480:
                colunaUnica = True
                colunas[i][0] = 6
            else:
                colunas[i][0] = 11
        elif colunas[i][1][0]&gt;228 and not re.search(r'Id: [0-9]*\n?', paragrafos[i][4]):
            if paragrafos[i][0] &gt; 400:
                colunas[i][0] = 5 if colunas[i][1][1] &gt; 530 else  11
            else:
                colunas[i][0] = 4  

</code></pre>
<p>A primeira parte do código trata daqueles parágrafos com grande largura, já que apenas alguns possuem essa característica. observamos a largura do parágrafo(<em>colunas[i][1][0]</em>) e sua centralidade(<em>colunas[i][1][0]</em>) assim conseguimos separar os parágrafos de coluna única(6), de duas colunas(4 e 5) por página ou colunas de extensão duplas(10 e 11) também nesse último caso de qual lado está o parágrafo.</p>
<pre><code class="language-python">        else:
            if re.search(r'Id: [0-9]*\n?', paragrafos[i][4]):
                if colunas[i][1][1] &lt; 279:
                    colunas[i][0] = 1
                elif colunas[i][1][1] &lt; 520 and colunas[i][1][0]&lt;228:
                    if 400&lt;paragrafos[i][2]&lt;488:
                        colunas[i][0] = 10
                        k=1
                        while i-k &gt; 0 and anexo &gt; 0:
                            colunas[i-k][0] = 10
                            regex = re.search(r'ANEXO ?([IVXL]+|\u00daNICO?|.*)', paragrafos[i-k][4])
                            if (regex and regex.span()[0]==0 ):
                                anexo-=1
                            k+=1
                        colunaUnica = False
                    if paragrafos[i][2]&lt;400:
                        colunas[i][0] = 4
                        k=1
                        while i-k &gt; 0 and anexo &gt; 0:
                            colunas[i-k][0] = 4
                            regex = re.search(r'ANEXO ?([IVXL]+|\u00daNICO?|.*)', paragrafos[i-k][4])
                            if (regex and regex.span()[0]==0 ):
                                anexo-=1
                            k+=1
                        colunaUnica = False
                    else:
                        colunas[i][0] = 2
                else:
                    if colunaUnica :
                        colunas[i][0] = 6
                    else:
                        colunas[i][0] = colunas[i-1][0]
                    k=1
                    while i-k &gt; 0 and anexo &gt; 0 :
                        if colunaUnica:
                            colunas[i-k][0] = 6

                        regex = re.search(r'ANEXO ?([IVXL]+|\u00daNICO?|.*)', paragrafos[i-k][4])
                        if (regex and regex.span()[0]==0):
                            anexo-=1
                        k+=1
                    colunaUnica = False
            elif not re.search(r'C *O *N *S *I *D *E *R *A *N *D *O *:|R *E *S *O *L *V *E *:|D *E *C *R *E *T *A *:', paragrafos[i][4]):
                if abs(colunas[i][1][1] - 222.655632019043) &lt; 125 and paragrafos[i][2] &gt; 280:
                    colunas[i][0] = 4
                elif 534 &gt; paragrafos[i][0] &gt; 420 : 
                    colunas[i][0] = 5
                elif 279 &lt; colunas[i][1][1] &lt; 480  :
                    colunas[i][0] = 2
                elif colunas[i][1][1] &lt; 279 and (abs(colunas[i][1][1] - 222.655632019043) &gt; abs(colunas[i][1][1] - 165.8691997528076) or (0 &lt; 122.3 - paragrafos[i][0] &lt; 0.2 and 0 &lt; 280 - paragrafos[i][2] &lt; 1 )):
                    colunas[i][0] = 1
                elif colunas[i][1][1] &lt; 279 and abs(colunas[i][1][1] - 222.655632019043) &lt; abs(colunas[i][1][1] - 165.8691997528076):
                    colunas[i][0] = 4
                elif colunas[i][1][1] &gt; 420 and (abs(colunas[i][1][1] - 590.9314880371094) &gt; abs(colunas[i][1][1] - 647.7062683105469) or 0 &lt;  534.4 - paragrafos[i][0]  &lt; 0.8):
                    colunas[i][0] = 3
                elif colunas[i][1][1] &gt; 420 and (abs(colunas[i][1][1] - 590.9314880371094) &lt; abs(colunas[i][1][1] - 647.7062683105469)):
                    colunas[i][0] = 5
            elif re.search(r'C *O *N *S *I *D *E *R *A *N *D *O *:|R *E *S *O *L *V *E *:|D *E *C *R *E *T *A *:', paragrafos[i][4]):
                if 0 &lt;  293.5 - paragrafos[i][0] &lt; 0.15:
                    colunas[i][0] = 2
                elif 0 &lt;  534.4 - paragrafos[i][0] &lt; 0.8:
                    colunas[i][0] = 3
                else:
                    colunas[i][0] = colunas[i-1][0]

    if verbose:                            
        for i in range(len(paragrafos)):
            print(colunas[i])

    return colunas
</code></pre>
<p>O caso dos parágrafos pequenos apresenta maior dificuldade de classificação uma vez que parágrafos de tipos diferentes podem acabar ocupando o mesmo espaço, assim para definirmos sua classificação devemos olhar aqueles que vem antes e/ou depois. O primeiro caso analizado é se há a presença do "Id" no paragrafo, assim podemos definir o tipo dele observando sua centralidade e posição de quem vem antes. Em seguida observamos mais atentamente os parâmetros existentes a fim de definir a coluna. Uma vez terminada a analize retornamos todas as métricas calculadas.</p>
<h3 id="sortcolunas"><em>sortColunas</em></h3>
<p>A função <em>sortColunas</em> tem como objetivo arrumar os paragrafos na ordem de leitura correto, assim garantindo sua corretude. Ela recebe 3 parâmetros de entrada, sendo eles o array a ser arrumado, o título da sessão sendo analizada e <em>verbose</em> para impressão em tela. Seu funcionamento ocorre ao percorrermos o array passado, observando se seus membros obedecem as regras abaixo:</p>
<ol>
<li>Se eu estou na mesma página, não posso subir na mesma coluna</li>
<li>Se eu estou na mesma página, não posso subir para a esquerda</li>
</ol>
<p>outras regras se mostram necessarias para casos mais específicos, entretanto essas duas já contemplam boa parte dos erros de formatação encontrados.</p>
<pre><code class="language-python">def sortColunas(colunas,Titulo, verbose = False):
    from re import search

    for i in range(len(colunas)):
        if i == 0 and colunas[i][2][4] != Titulo:
            print(colunas[i][2][4],&quot;O titulo da sessão e o das colunas não batem&quot;) if verbose else &quot;&quot;
            break
        elif i == 0: 
            colunas[i][0] = colunas[i+1][0]
        antes = colunas[i-1]
        agora = colunas[i]
        depois = colunas[i+1] if i+1 &lt; len(colunas)-1 else &quot;&quot;

        # corrigindo a coluna de alguns que passaram
        if depois != &quot;&quot; and antes[0] == depois[0] and antes[0] != agora[0] and antes[1][-1]&lt;agora[1][-2]&lt;depois[1][-2]:
            print(cores[&quot;ciano&quot;]+&quot;\nConfundi Coluna: &quot;+cores[&quot;reset&quot;], antes[0],agora[0], depois[0]) if verbose else &quot;&quot;
            agora[0] = antes[0]
            input() if verbose else &quot;&quot;
        # Corrigindo coluna unica
        if depois != &quot;&quot; and depois[0] == 6 and agora[0] in [1,2,4,10] and not search(r'ANEXO ?([IVXL]+|\u00daNICO?|.*)', depois[2][4]):
            print(cores[&quot;amarelo&quot;]+&quot;Achei coluna unica: &quot;+cores[&quot;reset&quot;]) if verbose else &quot;&quot;
            k=0
            abaixo = depois
            while i-k&gt;=0 and not (search(r'DECRETO', colunas[i-k][2][4]) and search(r'DECRETO', colunas[i-k][2][4]).span()[0] == 0) and colunas[i-k][0] in [1,2,4,10] and colunas[i-k][1][-1]&lt;abaixo[1][-2] and abaixo[2][-1] == colunas[i-k][2][-1]:
                colunas[i-k][0] = 6
                abaixo = colunas[i-k]
                k+=1
            colunas[i-k][0] = 6
            agora = colunas[i]
            print(colunas[i-k]) if verbose else &quot;&quot;
            print(colunas[i-k+1]) if verbose else &quot;&quot;
            print(&quot;parei em &quot;, colunas[i-k], &quot;\n&quot;) if verbose else &quot;&quot;
            input() if verbose else &quot;&quot;

        # se em mesma pagina
        if agora[2][-1] == antes[2][-1]:
            # se eu estou acima do meu antecessor
            if agora[1][-2]&lt;antes[1][-1]:
                # se estou na mesma coluna que meu antecessor
                if agora[0] == antes[0] :
                    print(cores[&quot;azul&quot;] + &quot;\nMesma coluna Errado:&quot; + cores[&quot;reset&quot;],agora[0], agora[1][-2], antes[1][-1]) if verbose else &quot;&quot;
                    k=1
                    while i-k &gt;= 0 and agora[1][-2] &lt; colunas[i-k][1][-1] and agora[0] == colunas[i-k][0] and agora[2][-1] == colunas[i-k][2][-1]  :
                        k+=1
                    print(&quot;Botei antes de&quot;, i-k+1, colunas[i-k][0:2]) if verbose else &quot;&quot;
                    aux = colunas.pop(i)
                    colunas.insert(i-k+1, aux)
                    print(colunas[i-k][0:2]) if verbose else &quot;&quot;
                    print(colunas[i-k+1][0:2]) if verbose else &quot;&quot;
                    print(colunas[i-k+2][0:2]) if verbose else &quot;&quot;
                    input() if verbose else &quot;&quot;

                # se estou em uma coluna antes do meu antecessor
                elif agora[0]&lt;antes[0]:
                    print(&quot;\033[2J\033[H&quot;, end='') if verbose else &quot;&quot;
                    for a in range(i):
                        print(colunas[a]) if verbose else &quot;&quot;

                    print(cores[&quot;verde&quot;] + &quot;\ndiferentes coluna Errado:&quot; + cores[&quot;reset&quot;] , agora[0:2], antes[0:2]) if verbose else &quot;&quot;
                    k=1
                    while i-k&gt;=0 and (agora[2][-1] == colunas[i-k][2][-1]):
                        if (agora[0] == colunas[i-k][0] and agora[1][-2] &gt; colunas[i-k][1][-1]) or (colunas[i-k][0] &lt; agora[0]):
                            break
                        k+=1
                    print(&quot;Botei antes de&quot;, i-k, colunas[i-k][0:2]) if verbose else &quot;&quot;
                    aux = colunas.pop(i)
                    colunas.insert(i-k+1, aux)
                    print(colunas[i-k][0:2]) if verbose else &quot;&quot;
                    print(colunas[i-k+1][0:2]) if verbose else &quot;&quot;
                    print(colunas[i-k+2][0:2]) if verbose else &quot;&quot;
                    input() if verbose else &quot;&quot;

    if verbose:                            
        for i in range(len(colunas)):
            print(colunas[i])

    return colunas
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Navegação no rodapé">
        <a href="../extracaoTratamentoPainelSETD/" class="btn btn-neutral float-left" title="extracao_tratamento_painel_SETD.py"><span class="icon icon-circle-arrow-left"></span> Anterior</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Construído com <a href="https://www.mkdocs.org/">MkDocs</a> usando um <a href="https://github.com/readthedocs/sphinx_rtd_theme">tema</a> provido por <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versões">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../extracaoTratamentoPainelSETD/" style="color: #fcfcfc">&laquo; Anterior</a></span>
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
